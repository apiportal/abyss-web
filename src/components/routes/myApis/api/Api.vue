<template>
  <div class="api-container">
    <FinderLayout
      name="pet3"
      :path="path"
      :onPathChange="handlePathChange"
    >
      <template>
        <FinderColumn
          v-for="(column, columnIndex) in columns"
          v-bind:key="columnIndex"
        >
          <template>
            <FinderColumnObject
              :data="column.propData"
              :objectInterface="column.interface"
              :interfaceKey="column.interfaceKey"
              :isArray="column.isArray"
              :isMap="column.isMap"
              :columnIndex="columnIndex"
              :onPathChange="handlePathChange"
              :path="path"
            />
          </template>
        </FinderColumn>
      </template>
    </FinderLayout>
    <div style="flex: 1 0 0; border-left: 1px solid silver; overflow-y: scroll;">
      <AutoGeneratedForm
        v-if="columns.length > 0"
        :formData="columns.length > 1 ? columns[columns.length - 1] : columns[0]"
        :interfaces="interfaces"
      />
    </div>
  </div>
</template>

<script>
// import api from '@/api';
import FinderLayout from '@/components/shared/finder/FinderLayout';
import FinderColumn from '@/components/shared/finder/FinderColumn';
import FinderColumnObject from '@/components/shared/finder/FinderColumnObject';
import AutoGeneratedForm from '@/components/shared/autoGeneratedForm/AutoGeneratedForm';
// import Editor from '@/components/shared/Editor';
// import SwaggerEditor from '@/components/shared/SwaggerEditor';
import Interfaces from '@/assets/openAPI3.0.json';
import Pet3 from '@/assets/pet3.json';

export default {
  components: {
    FinderLayout,
    FinderColumn,
    FinderColumnObject,
    AutoGeneratedForm,
    // Editor,
    // SwaggerEditor,
  },
  computed: {
    columns() {
      return this.path.map((item, index) => {
        const { apiData, interfaces, path } = this;

        return {
          propData: this.getPropData({ obj: apiData, keys: path.slice(1, (index + 1)) }),
          ...this.getPropInterface({ interfaces, keys: path.slice(1, (index + 1)) }),
        };
      }).filter(item => (typeof item.propData === 'object'));
    },
  },
  data() {
    return {
      apiData: Pet3,
      interfaces: Interfaces,
      path: [''],
    };
  },
  mounted() {
  },
  methods: {
    handlePathChange({ columnIndex, propName }) {
      this.path = [...this.path.slice(0, (columnIndex + 1)), propName];
    },
    getPropData({ obj = {}, keys = [] }) {
      return keys.reduce((reducedObj, key) => (reducedObj[key] ? reducedObj[key] : {}), obj);
    },
    getPropInterface({
      interfaces,
      keys,
      currentInterfaceKey = 'Root Object',
      currentKeyIndex = 0,
      isParentArray = false,
      isParentMap = false,
    }) {
      if (keys.length === 0) {
        return {
          interface: interfaces['Root Object'],
          interfaceKey: 'Root Object',
        };
      }

      const currentInterface = interfaces[currentInterfaceKey];
      const currentKey = keys[currentKeyIndex];

      if (currentKeyIndex < keys.length) {
        if (isParentArray || isParentMap) {
          // ARRAY || MAP -> PASS PROPS TO CHILD KEY
          return this.getPropInterface({
            interfaces,
            keys,
            currentInterfaceKey,
            currentKeyIndex: (currentKeyIndex + 1),
            isParentArray: false,
            isParentMap: false,
          });
        }
        // NOT A DEFINED INTERFACE
        if (!(currentInterface[currentKey] && currentInterface[currentKey].type)) {
          // CHECK REGEX MATCH
          const currentInterfaceProps = Object.keys(currentInterface);
          const matchedInterfaceProp = currentInterfaceProps.find((item) => {
            if (currentInterface[item].regex) {
              return Boolean(item.match(new RegExp(currentInterface[item].regex), 'g'));
            }
            return false;
          });
          if (matchedInterfaceProp) {
            // REGEX MATCHED
            return this.getPropInterface({
              interfaces,
              keys,
              currentInterfaceKey: currentInterface[matchedInterfaceProp].type,
              currentKeyIndex: (currentKeyIndex + 1),
              isParentArray: currentInterface[matchedInterfaceProp].Array,
              isParentMap: currentInterface[matchedInterfaceProp].Map,
            });
          }
          return false;
        }
        // FOUND INTERFACE
        return this.getPropInterface({
          interfaces,
          keys,
          currentInterfaceKey: currentInterface[currentKey].type,
          currentKeyIndex: (currentKeyIndex + 1),
          isParentArray: currentInterface[currentKey].Array,
          isParentMap: currentInterface[currentKey].Map,
        });
      }

      return {
        interface: ((isParentArray || isParentMap) ? {} : interfaces[currentInterfaceKey]),
        interfaceKey: currentInterfaceKey,
        isArray: isParentArray,
        isMap: isParentMap,
      };
    },
    getColumnData({ propData }) {
      const dataType = (typeof propData);

      if (dataType === 'object') {
        return {
          type: dataType,
          propNames: Object.keys(propData),
        };
      }
      return {
        type: dataType,
        data: propData,
      };
    },
  },
};
</script>

<style lang="scss" scoped>
.api-container {
  display: flex;
  flex-direction: row;
  flex: 1 0 0;
}

.editor-container {
  flex: 600px 0 0;
  border-left: 1px solid silver;
  display: flex;
  flex-direction: row;
}
</style>